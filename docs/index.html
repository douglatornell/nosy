<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="author" content="Doug Latornell">
  <meta name="copyright" content="&copy;2008 Doug Latornell">
  <meta name="created" content="2008-05-18">
  <title>Nosy Reloaded</title>
</head>

<body>
  <h3>
    Hacking on <a
    href="http://jeffwinkler.net/2006/04/27/keeping-your-nose-green/">
    Jeff Winkler's Nosy</a>
  </h3>
  <p>
    I discovered Jason
    Pellerin's <a
    href="http://www.somethingaboutorange.com/mrl/projects/nose/">nose</a>
    test discovery and execution tool when I started
    using <a href="http://turbogears.org/">TurboGears</a>.  My first
    forays into test driven development and automated Python testing
    weren't all that successful though.
    Then <a
    href="http://us.pycon.org/2008/conference/schedule/event/53/">this
    talk</a> by <a href="http://tartley.com/">Jonathan Hartley</a>
    and <a
    href="http://us.pycon.org/2008/conference/schedule/event/83/">this
    one</a> by <a href="http://ivory.idyll.org/blog">Titus Brown</a>
    at PyCon 2008, and a lobby chat with Jonathan just before I left
    Chicago got me thinking differently, and more seriously about
    automated testing.  A few days later, the penny dropped, and I'm a
    convert!
  </p>
  <p>
    Then I came across Jeff
    Winkler's <a
    href="http://jeffwinkler.net/2006/04/27/keeping-your-nose-green/">
    nosy</a> script that runs <code> nose</code> whenever a source
    file has changed.  I'd thought about doing something like that but
    was thinking I'd have to use some kind of continuous integration
    system like <a href="http://buildbot.net/trac">buildbot</a>, and
    that seemed like a whole lot of trouble for some little personal
    projects.  Jeff's trick for calculating a checksum for the source
    files makes it all very, <em>very</em> easy.
    His <a href="http://jeffwinkler.net/jwfiles/nosy/nosy.py">original
    nosy.py script</a> is less than 20 lines long!
  </p>
  <p>
    I liked <code>nosy</code> on sight but after playing with it for a
    short time wanted to add features and flexibility.  I like to keep
    my test code in a <code>tests/</code> directory, separate from my
    project code.  I wanted <code>nose</code> to run whenever I
    changed either the project code, or the test code.  I wanted to be
    able to change the way <code>nose</code> ran, turning options
    like <code>-s</code> and <code>-v</code> on or off, and specifying
    particular parts of the test suite to run via command line
    arguments.
  </p>
  <p>
    So, I decided that <code>nosy</code> needed the option of having a
    configuration file.  Of course that meant that it needed a command
    line
    processor.  <a
    href="http://docs.python.org/lib/module-ConfigParser.html">ConfigParser</a>
    and <a
    href="http://docs.python.org/lib/module-optparse.html">optparse</a>
    from the Python standard library to the rescue, and we
    have <a href="nosy.py">my version of nosy</a>:
    <pre>
      <code>
	$ nosy -h
	Usage: nosy [options]

	Automatically run nose whenever source files change.

	Options:
	  -h, --help            show this help message and exit
	  -c CONFIG_FILE, --config=CONFIG_FILE
                                Configuration file path and name
      </code>
    </pre>
  </p>
  <p>
    I've created a 
    <a href="http://peak.telecommunity.com/DevCenter/setuptools">
      <code>setuptools</code></a> source distribution package that you
    should be able to install with:
    <pre>
      <code>
	$ easy_install http://douglatornell.ca/software/python/nosy/Nosy-1.0.tar.gz
      </code>
    </pre>
  </p>
  <p>
    Throw a config file something like <a href="sample.cfg">this
    sample</a>:
    <pre>
      <code>
	# Sample config file for nosy

	# Including this file in the paths to check allows you to change
	# nose's behaviour on the fly.

	[nosy]
	# Paths to check for changed files; changes cause nose to be run
	paths = *.py tests/*.py tests/nosy.cfg
	# Command line options to pass to nose
	options = -s
	# Command line arguments to pass to nose; e.g. part of test suite to run
	tests = tests/unit_tests.py

	# end of file
      </code>
    </pre>
    in your <code>tests/</code> directory as <code>nosy.cfg</code>,
    launch nosy with:
    <pre>
      <code>
	$ nosy -c tests/nosy.cfg
      </code>
    </pre>
    and away you go.  <code>nose</code> will run whenever <code>
    *.py</code> in the current directory, or <code>
    tests/*.py</code>, or <code>tests/nosy.cfg</code> change.
  </p>
  <p>
    The <code>paths</code> option in the config file controls which
    files are monitored for changes.  Putting the config file itself
    in that list allows you to change how <code>nose</code> runs
    without having to stop and restart <code>nosy</code>.
  </p>
  <p>
    <code>options</code> are the command line options to pass
    to <code>nose</code>. Use <code>-v</code> to turn on verbose
    output, or <code>-a foo</code> to run only the tests with
    attribute <code>foo</code>.
  </p>
  <p>
    <code>tests</code> are the command line arguments to pass to
    <code>nose</code>, used to select specific tests to run.
  </p>
  <hr>
</body>

</html>
